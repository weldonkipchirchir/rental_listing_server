// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: booking.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const countBookingsByUserID = `-- name: CountBookingsByUserID :one
SELECT COUNT(*)
FROM bookings
WHERE user_id = $1
`

func (q *Queries) CountBookingsByUserID(ctx context.Context, userID int32) (int64, error) {
	row := q.db.QueryRowContext(ctx, countBookingsByUserID, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createBooking = `-- name: CreateBooking :one
INSERT INTO bookings (user_id, listing_id, check_in_date, check_out_date, total_amount)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, user_id, listing_id, check_in_date, check_out_date, total_amount, status, created_at
`

type CreateBookingParams struct {
	UserID       int32     `json:"user_id"`
	ListingID    int32     `json:"listing_id"`
	CheckInDate  time.Time `json:"check_in_date"`
	CheckOutDate time.Time `json:"check_out_date"`
	TotalAmount  string    `json:"total_amount"`
}

type CreateBookingRow struct {
	ID           int32          `json:"id"`
	UserID       int32          `json:"user_id"`
	ListingID    int32          `json:"listing_id"`
	CheckInDate  time.Time      `json:"check_in_date"`
	CheckOutDate time.Time      `json:"check_out_date"`
	TotalAmount  string         `json:"total_amount"`
	Status       sql.NullString `json:"status"`
	CreatedAt    sql.NullTime   `json:"created_at"`
}

func (q *Queries) CreateBooking(ctx context.Context, arg CreateBookingParams) (CreateBookingRow, error) {
	row := q.db.QueryRowContext(ctx, createBooking,
		arg.UserID,
		arg.ListingID,
		arg.CheckInDate,
		arg.CheckOutDate,
		arg.TotalAmount,
	)
	var i CreateBookingRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ListingID,
		&i.CheckInDate,
		&i.CheckOutDate,
		&i.TotalAmount,
		&i.Status,
		&i.CreatedAt,
	)
	return i, err
}

const deleteUserBooking = `-- name: DeleteUserBooking :exec
UPDATE bookings
SET deleted_at = NOW()
WHERE id = $1 AND user_id = $2
`

type DeleteUserBookingParams struct {
	ID     int32 `json:"id"`
	UserID int32 `json:"user_id"`
}

func (q *Queries) DeleteUserBooking(ctx context.Context, arg DeleteUserBookingParams) error {
	_, err := q.db.ExecContext(ctx, deleteUserBooking, arg.ID, arg.UserID)
	return err
}

const getBookingsByAdminID = `-- name: GetBookingsByAdminID :many
SELECT 
    b.id, 
    l.title,
    l.location, 
    b.user_id, 
    u.username AS user_username,
    u.email AS user_email,
    b.listing_id, 
    b.check_in_date, 
    b.check_out_date, 
    b.total_amount, 
    b.status, 
    b.created_at
FROM 
    bookings b
JOIN 
    listings l ON b.listing_id = l.id
JOIN 
    users u ON b.user_id = u.id  
WHERE 
    l.admin_id = $1 AND (b.status = 'completed' OR b.status = 'confirmed' OR b.status = 'pending')
ORDER BY 
    b.created_at DESC
`

type GetBookingsByAdminIDRow struct {
	ID           int32          `json:"id"`
	Title        string         `json:"title"`
	Location     sql.NullString `json:"location"`
	UserID       int32          `json:"user_id"`
	UserUsername string         `json:"user_username"`
	UserEmail    string         `json:"user_email"`
	ListingID    int32          `json:"listing_id"`
	CheckInDate  time.Time      `json:"check_in_date"`
	CheckOutDate time.Time      `json:"check_out_date"`
	TotalAmount  string         `json:"total_amount"`
	Status       sql.NullString `json:"status"`
	CreatedAt    sql.NullTime   `json:"created_at"`
}

func (q *Queries) GetBookingsByAdminID(ctx context.Context, adminID int32) ([]GetBookingsByAdminIDRow, error) {
	rows, err := q.db.QueryContext(ctx, getBookingsByAdminID, adminID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetBookingsByAdminIDRow
	for rows.Next() {
		var i GetBookingsByAdminIDRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Location,
			&i.UserID,
			&i.UserUsername,
			&i.UserEmail,
			&i.ListingID,
			&i.CheckInDate,
			&i.CheckOutDate,
			&i.TotalAmount,
			&i.Status,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBookingsByAdminIDByID = `-- name: GetBookingsByAdminIDByID :one
SELECT b.id, b.user_id, b.listing_id, b.check_in_date, b.check_out_date, b.total_amount, b.status, b.created_at
FROM bookings b
JOIN listings l ON b.listing_id = l.id
WHERE l.admin_id = $1 AND b.id = $2
ORDER BY b.created_at DESC
`

type GetBookingsByAdminIDByIDParams struct {
	AdminID int32 `json:"admin_id"`
	ID      int32 `json:"id"`
}

type GetBookingsByAdminIDByIDRow struct {
	ID           int32          `json:"id"`
	UserID       int32          `json:"user_id"`
	ListingID    int32          `json:"listing_id"`
	CheckInDate  time.Time      `json:"check_in_date"`
	CheckOutDate time.Time      `json:"check_out_date"`
	TotalAmount  string         `json:"total_amount"`
	Status       sql.NullString `json:"status"`
	CreatedAt    sql.NullTime   `json:"created_at"`
}

func (q *Queries) GetBookingsByAdminIDByID(ctx context.Context, arg GetBookingsByAdminIDByIDParams) (GetBookingsByAdminIDByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getBookingsByAdminIDByID, arg.AdminID, arg.ID)
	var i GetBookingsByAdminIDByIDRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ListingID,
		&i.CheckInDate,
		&i.CheckOutDate,
		&i.TotalAmount,
		&i.Status,
		&i.CreatedAt,
	)
	return i, err
}

const getBookingsByListingID = `-- name: GetBookingsByListingID :many
SELECT b.id, b.user_id, b.listing_id, b.check_in_date, b.check_out_date, b.total_amount, b.status, b.created_at
FROM bookings b
JOIN listings l ON b.listing_id = l.id
WHERE b.listing_id = $1 AND l.admin_id = $2
ORDER BY b.created_at DESC
`

type GetBookingsByListingIDParams struct {
	ListingID int32 `json:"listing_id"`
	AdminID   int32 `json:"admin_id"`
}

type GetBookingsByListingIDRow struct {
	ID           int32          `json:"id"`
	UserID       int32          `json:"user_id"`
	ListingID    int32          `json:"listing_id"`
	CheckInDate  time.Time      `json:"check_in_date"`
	CheckOutDate time.Time      `json:"check_out_date"`
	TotalAmount  string         `json:"total_amount"`
	Status       sql.NullString `json:"status"`
	CreatedAt    sql.NullTime   `json:"created_at"`
}

func (q *Queries) GetBookingsByListingID(ctx context.Context, arg GetBookingsByListingIDParams) ([]GetBookingsByListingIDRow, error) {
	rows, err := q.db.QueryContext(ctx, getBookingsByListingID, arg.ListingID, arg.AdminID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetBookingsByListingIDRow
	for rows.Next() {
		var i GetBookingsByListingIDRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ListingID,
			&i.CheckInDate,
			&i.CheckOutDate,
			&i.TotalAmount,
			&i.Status,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBookingsByUserID = `-- name: GetBookingsByUserID :many
SELECT b.id, l.title, a.id, a.username, a.email, b.user_id, b.listing_id, b.check_in_date, b.check_out_date, b.total_amount, b.status, b.created_at
FROM bookings b
JOIN listings l ON b.listing_id = l.id
JOIN admins a ON l.admin_id = a.id
WHERE b.user_id = $1 AND deleted_at IS NULL
ORDER BY b.created_at DESC
`

type GetBookingsByUserIDRow struct {
	ID           int32          `json:"id"`
	Title        string         `json:"title"`
	ID_2         int32          `json:"id_2"`
	Username     string         `json:"username"`
	Email        string         `json:"email"`
	UserID       int32          `json:"user_id"`
	ListingID    int32          `json:"listing_id"`
	CheckInDate  time.Time      `json:"check_in_date"`
	CheckOutDate time.Time      `json:"check_out_date"`
	TotalAmount  string         `json:"total_amount"`
	Status       sql.NullString `json:"status"`
	CreatedAt    sql.NullTime   `json:"created_at"`
}

func (q *Queries) GetBookingsByUserID(ctx context.Context, userID int32) ([]GetBookingsByUserIDRow, error) {
	rows, err := q.db.QueryContext(ctx, getBookingsByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetBookingsByUserIDRow
	for rows.Next() {
		var i GetBookingsByUserIDRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.ID_2,
			&i.Username,
			&i.Email,
			&i.UserID,
			&i.ListingID,
			&i.CheckInDate,
			&i.CheckOutDate,
			&i.TotalAmount,
			&i.Status,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserBookingByID = `-- name: GetUserBookingByID :one
SELECT id, user_id, listing_id, check_in_date, check_out_date, total_amount, status, created_at
FROM bookings
WHERE id = $1 AND user_id = $2
`

type GetUserBookingByIDParams struct {
	ID     int32 `json:"id"`
	UserID int32 `json:"user_id"`
}

type GetUserBookingByIDRow struct {
	ID           int32          `json:"id"`
	UserID       int32          `json:"user_id"`
	ListingID    int32          `json:"listing_id"`
	CheckInDate  time.Time      `json:"check_in_date"`
	CheckOutDate time.Time      `json:"check_out_date"`
	TotalAmount  string         `json:"total_amount"`
	Status       sql.NullString `json:"status"`
	CreatedAt    sql.NullTime   `json:"created_at"`
}

func (q *Queries) GetUserBookingByID(ctx context.Context, arg GetUserBookingByIDParams) (GetUserBookingByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getUserBookingByID, arg.ID, arg.UserID)
	var i GetUserBookingByIDRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ListingID,
		&i.CheckInDate,
		&i.CheckOutDate,
		&i.TotalAmount,
		&i.Status,
		&i.CreatedAt,
	)
	return i, err
}

const updateBookingStatusByIDAndAdminID = `-- name: UpdateBookingStatusByIDAndAdminID :exec
UPDATE bookings b
SET status = COALESCE($1, status)
FROM listings l
WHERE b.listing_id = l.id AND b.id = $2 AND l.admin_id = $3
RETURNING b.id, b.user_id, b.listing_id, b.check_in_date, b.check_out_date, b.total_amount, b.status, b.created_at
`

type UpdateBookingStatusByIDAndAdminIDParams struct {
	Status  sql.NullString `json:"status"`
	ID      int32          `json:"id"`
	AdminID int32          `json:"admin_id"`
}

func (q *Queries) UpdateBookingStatusByIDAndAdminID(ctx context.Context, arg UpdateBookingStatusByIDAndAdminIDParams) error {
	_, err := q.db.ExecContext(ctx, updateBookingStatusByIDAndAdminID, arg.Status, arg.ID, arg.AdminID)
	return err
}

const updateBookingStatusByIDAndUserID = `-- name: UpdateBookingStatusByIDAndUserID :exec
UPDATE bookings
SET status = 'cancelled'
WHERE id = $1 AND user_id = $2
`

type UpdateBookingStatusByIDAndUserIDParams struct {
	ID     int32 `json:"id"`
	UserID int32 `json:"user_id"`
}

func (q *Queries) UpdateBookingStatusByIDAndUserID(ctx context.Context, arg UpdateBookingStatusByIDAndUserIDParams) error {
	_, err := q.db.ExecContext(ctx, updateBookingStatusByIDAndUserID, arg.ID, arg.UserID)
	return err
}
