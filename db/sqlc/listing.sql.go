// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: listing.sql

package db

import (
	"context"
	"database/sql"

	"github.com/lib/pq"
)

const createListing = `-- name: CreateListing :one
INSERT INTO listings (admin_id, title, description, price, location, available, imageLinks)
VALUES ($1, $2, $3, $4, $5, $6, $7::text[]
)
RETURNING id, admin_id, title, description, price, location, available, imageLinks, created_at
`

type CreateListingParams struct {
	AdminID     int32          `json:"admin_id"`
	Title       string         `json:"title"`
	Description sql.NullString `json:"description"`
	Price       string         `json:"price"`
	Location    sql.NullString `json:"location"`
	Available   sql.NullBool   `json:"available"`
	Column7     []string       `json:"column_7"`
}

type CreateListingRow struct {
	ID          int32          `json:"id"`
	AdminID     int32          `json:"admin_id"`
	Title       string         `json:"title"`
	Description sql.NullString `json:"description"`
	Price       string         `json:"price"`
	Location    sql.NullString `json:"location"`
	Available   sql.NullBool   `json:"available"`
	Imagelinks  []string       `json:"imagelinks"`
	CreatedAt   sql.NullTime   `json:"created_at"`
}

func (q *Queries) CreateListing(ctx context.Context, arg CreateListingParams) (CreateListingRow, error) {
	row := q.db.QueryRowContext(ctx, createListing,
		arg.AdminID,
		arg.Title,
		arg.Description,
		arg.Price,
		arg.Location,
		arg.Available,
		pq.Array(arg.Column7),
	)
	var i CreateListingRow
	err := row.Scan(
		&i.ID,
		&i.AdminID,
		&i.Title,
		&i.Description,
		&i.Price,
		&i.Location,
		&i.Available,
		pq.Array(&i.Imagelinks),
		&i.CreatedAt,
	)
	return i, err
}

const deleteListing = `-- name: DeleteListing :exec
DELETE FROM listings
WHERE id = $1 AND admin_id = $2
`

type DeleteListingParams struct {
	ID      int32 `json:"id"`
	AdminID int32 `json:"admin_id"`
}

func (q *Queries) DeleteListing(ctx context.Context, arg DeleteListingParams) error {
	_, err := q.db.ExecContext(ctx, deleteListing, arg.ID, arg.AdminID)
	return err
}

const getAdminListings = `-- name: GetAdminListings :many
SELECT id, admin_id, title, description, price, location, available, imageLinks, created_at
FROM listings
WHERE admin_id = $1
ORDER BY created_at DESC
`

type GetAdminListingsRow struct {
	ID          int32          `json:"id"`
	AdminID     int32          `json:"admin_id"`
	Title       string         `json:"title"`
	Description sql.NullString `json:"description"`
	Price       string         `json:"price"`
	Location    sql.NullString `json:"location"`
	Available   sql.NullBool   `json:"available"`
	Imagelinks  []string       `json:"imagelinks"`
	CreatedAt   sql.NullTime   `json:"created_at"`
}

func (q *Queries) GetAdminListings(ctx context.Context, adminID int32) ([]GetAdminListingsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAdminListings, adminID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAdminListingsRow
	for rows.Next() {
		var i GetAdminListingsRow
		if err := rows.Scan(
			&i.ID,
			&i.AdminID,
			&i.Title,
			&i.Description,
			&i.Price,
			&i.Location,
			&i.Available,
			pq.Array(&i.Imagelinks),
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getListingByID = `-- name: GetListingByID :one
SELECT id, admin_id, title, description, price, location, available, imageLinks, created_at
FROM listings
WHERE id = $1
`

type GetListingByIDRow struct {
	ID          int32          `json:"id"`
	AdminID     int32          `json:"admin_id"`
	Title       string         `json:"title"`
	Description sql.NullString `json:"description"`
	Price       string         `json:"price"`
	Location    sql.NullString `json:"location"`
	Available   sql.NullBool   `json:"available"`
	Imagelinks  []string       `json:"imagelinks"`
	CreatedAt   sql.NullTime   `json:"created_at"`
}

func (q *Queries) GetListingByID(ctx context.Context, id int32) (GetListingByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getListingByID, id)
	var i GetListingByIDRow
	err := row.Scan(
		&i.ID,
		&i.AdminID,
		&i.Title,
		&i.Description,
		&i.Price,
		&i.Location,
		&i.Available,
		pq.Array(&i.Imagelinks),
		&i.CreatedAt,
	)
	return i, err
}

const getListings = `-- name: GetListings :many
SELECT id, admin_id, title, description, price, location, available, imageLinks, created_at
FROM listings
WHERE available = TRUE
ORDER BY created_at DESC
`

type GetListingsRow struct {
	ID          int32          `json:"id"`
	AdminID     int32          `json:"admin_id"`
	Title       string         `json:"title"`
	Description sql.NullString `json:"description"`
	Price       string         `json:"price"`
	Location    sql.NullString `json:"location"`
	Available   sql.NullBool   `json:"available"`
	Imagelinks  []string       `json:"imagelinks"`
	CreatedAt   sql.NullTime   `json:"created_at"`
}

func (q *Queries) GetListings(ctx context.Context) ([]GetListingsRow, error) {
	rows, err := q.db.QueryContext(ctx, getListings)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetListingsRow
	for rows.Next() {
		var i GetListingsRow
		if err := rows.Scan(
			&i.ID,
			&i.AdminID,
			&i.Title,
			&i.Description,
			&i.Price,
			&i.Location,
			&i.Available,
			pq.Array(&i.Imagelinks),
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getListingsByAdminID = `-- name: GetListingsByAdminID :one
SELECT id, admin_id, title, description, price, location, available, imageLinks, created_at
FROM listings
WHERE admin_id = $1 AND id = $2
`

type GetListingsByAdminIDParams struct {
	AdminID int32 `json:"admin_id"`
	ID      int32 `json:"id"`
}

type GetListingsByAdminIDRow struct {
	ID          int32          `json:"id"`
	AdminID     int32          `json:"admin_id"`
	Title       string         `json:"title"`
	Description sql.NullString `json:"description"`
	Price       string         `json:"price"`
	Location    sql.NullString `json:"location"`
	Available   sql.NullBool   `json:"available"`
	Imagelinks  []string       `json:"imagelinks"`
	CreatedAt   sql.NullTime   `json:"created_at"`
}

func (q *Queries) GetListingsByAdminID(ctx context.Context, arg GetListingsByAdminIDParams) (GetListingsByAdminIDRow, error) {
	row := q.db.QueryRowContext(ctx, getListingsByAdminID, arg.AdminID, arg.ID)
	var i GetListingsByAdminIDRow
	err := row.Scan(
		&i.ID,
		&i.AdminID,
		&i.Title,
		&i.Description,
		&i.Price,
		&i.Location,
		&i.Available,
		pq.Array(&i.Imagelinks),
		&i.CreatedAt,
	)
	return i, err
}

const listingActiveBookingCount = `-- name: ListingActiveBookingCount :one
SELECT COUNT(*) AS confirmed_count
FROM bookings b
JOIN listings l ON b.listing_id = l.id
WHERE b.listing_id = $1 AND b.status = 'confirmed' AND l.admin_id = $2
`

type ListingActiveBookingCountParams struct {
	ListingID int32 `json:"listing_id"`
	AdminID   int32 `json:"admin_id"`
}

func (q *Queries) ListingActiveBookingCount(ctx context.Context, arg ListingActiveBookingCountParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, listingActiveBookingCount, arg.ListingID, arg.AdminID)
	var confirmed_count int64
	err := row.Scan(&confirmed_count)
	return confirmed_count, err
}

const searchListings = `-- name: SearchListings :many
SELECT id, admin_id, title, description, price, location, available, imageLinks, created_at
FROM listings
WHERE 
    (title ILIKE '%' || $1 || '%' OR description ILIKE '%' || $1 || '%') 
    AND available = TRUE
ORDER BY created_at DESC
`

type SearchListingsRow struct {
	ID          int32          `json:"id"`
	AdminID     int32          `json:"admin_id"`
	Title       string         `json:"title"`
	Description sql.NullString `json:"description"`
	Price       string         `json:"price"`
	Location    sql.NullString `json:"location"`
	Available   sql.NullBool   `json:"available"`
	Imagelinks  []string       `json:"imagelinks"`
	CreatedAt   sql.NullTime   `json:"created_at"`
}

func (q *Queries) SearchListings(ctx context.Context, dollar_1 sql.NullString) ([]SearchListingsRow, error) {
	rows, err := q.db.QueryContext(ctx, searchListings, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchListingsRow
	for rows.Next() {
		var i SearchListingsRow
		if err := rows.Scan(
			&i.ID,
			&i.AdminID,
			&i.Title,
			&i.Description,
			&i.Price,
			&i.Location,
			&i.Available,
			pq.Array(&i.Imagelinks),
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const statistics = `-- name: Statistics :many
SELECT
    l.id,
    l.title,
    l.total_views,
    COUNT(DISTINCT b.id) AS total_bookings,
    CASE 
        WHEN COUNT(r.id) > 0 THEN ROUND(AVG(r.rating)::numeric, 2)
        ELSE NULL
    END AS average_rating,
    COALESCE(SUM(CASE 
        WHEN b.status IN ('confirmed', 'completed') THEN b.total_amount 
        ELSE 0 
    END), 0) AS total_confirmed_amount
FROM
    listings l
LEFT JOIN
    bookings b ON l.id = b.listing_id
LEFT JOIN
    reviews r ON l.id = r.listing_id
WHERE
    l.admin_id = $1
GROUP BY
    l.id, l.title, l.total_views
ORDER BY
    l.total_views DESC
`

type StatisticsRow struct {
	ID                   int32         `json:"id"`
	Title                string        `json:"title"`
	TotalViews           sql.NullInt32 `json:"total_views"`
	TotalBookings        int64         `json:"total_bookings"`
	AverageRating        interface{}   `json:"average_rating"`
	TotalConfirmedAmount interface{}   `json:"total_confirmed_amount"`
}

func (q *Queries) Statistics(ctx context.Context, adminID int32) ([]StatisticsRow, error) {
	rows, err := q.db.QueryContext(ctx, statistics, adminID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []StatisticsRow
	for rows.Next() {
		var i StatisticsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.TotalViews,
			&i.TotalBookings,
			&i.AverageRating,
			&i.TotalConfirmedAmount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateListing = `-- name: UpdateListing :exec
UPDATE listings
SET
    title = COALESCE($1, title),
    description = COALESCE($2, description),
    price = COALESCE($3, price),
    location = COALESCE($4, location),
    available = COALESCE($5, available),
    imageLinks = COALESCE($6, imageLinks)
WHERE id = $7 AND admin_id = $8
RETURNING id, admin_id, title, description, price, location, created_at, available, total_views, imagelinks
`

type UpdateListingParams struct {
	Title       sql.NullString `json:"title"`
	Description sql.NullString `json:"description"`
	Price       sql.NullString `json:"price"`
	Location    sql.NullString `json:"location"`
	Available   sql.NullBool   `json:"available"`
	Imagelinks  []string       `json:"imagelinks"`
	ID          int32          `json:"id"`
	AdminID     int32          `json:"admin_id"`
}

func (q *Queries) UpdateListing(ctx context.Context, arg UpdateListingParams) error {
	_, err := q.db.ExecContext(ctx, updateListing,
		arg.Title,
		arg.Description,
		arg.Price,
		arg.Location,
		arg.Available,
		pq.Array(arg.Imagelinks),
		arg.ID,
		arg.AdminID,
	)
	return err
}

const updateListingStatus = `-- name: UpdateListingStatus :exec
UPDATE listings
SET available = $2
WHERE id = $1
`

type UpdateListingStatusParams struct {
	ID        int32        `json:"id"`
	Available sql.NullBool `json:"available"`
}

func (q *Queries) UpdateListingStatus(ctx context.Context, arg UpdateListingStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateListingStatus, arg.ID, arg.Available)
	return err
}

const updateTotalViews = `-- name: UpdateTotalViews :exec
UPDATE listings
SET total_views = total_views + 1
WHERE id = $1
`

func (q *Queries) UpdateTotalViews(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, updateTotalViews, id)
	return err
}
